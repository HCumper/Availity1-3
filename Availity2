A book I have been thumbing through a lot recently is “Language Implementation Patterns” by Terence Parr (author of ANTLR https://www.antlr.org/). There is an old programming language called SuperBasic, subsequently revamped as SBasic, originating I the 1980’s which was the first language I ever used. It is now close to extinction. There are still many fondly remembered programs written in it though, so I took it into my head to write a transpiler to convert them into C#. I started with some a theoretical knowledge of compilers but no practical experience. I found most books on the subject were not very useful partly because they focused on compilers and partly because they taught the theory and some algorithms but were not intended as a guide to someone actually undertaking the task. 
Language implementation Patterns is different firstly because the author notes that very few people are actually writing compilers and true compilers have become an endangered species anyway in the face of bytecode languages like CLR and JIL. Conversely, transpilers are on the rise particularly with Typescript being implemented as one, though it is unusual in that strict correctness of output is required whereas readability is not a priority. My dealings with Typescript started in the days when it could not be debugged, only the generated JavaScript could be. Secondly, the focus is on application specific design patterns more than algorithms and integration thereof into a complete application.
The early phases of a transpiler concerned with analysis rather than synthesis are the same as compilers. The book contains a treatment of formal grammars, which is just rigorous enough for the task of writing one without needless formalisms. There is coverage of different parsing techniques (LL(1), LL(k),  LALR) and ways to implement them (backtracking, memorizing, and predicated). Writing a grammar for SBasic is tricky as it was not based on any formalisms and has multiple feature ill-suited to trans/compilation.  For instance the parameter passing mechanism is determined by the actual not the formal parameters and scoping is dynamic not lexical. The book goes onto a discussion of syntax trees – parse and abstract – and the value of tree rewriting. Rewriting is a fundamental technique in compilers but the author general recommends progressive annotation of the parse tree over rewriting for other language processing applications where the difference between input and target languages is not so great. The use of Walker and Visitor patterns to separate concerns and promote usability is also covered. Implementation in an OO language creates options for encoding source language syntactic features in the type system using heterogeneous trees instead of storing them in the node in the traditional manner. The book goes onto the subject of symbol tables skipping the usual formal definition but addressing the problem of data aggregates and how scope trees can address it. These issues are becoming ever more prominent with the spread of OO languages. The next stage is annotation of the syntax tree with type information for semantic validation, type promotion and in some cases type inference. 
Parr then devotes a section to building interpreters, especially bytecode interpreters, with advice on the degree of prior analysis that should be carried based on the extent of the mapping required between source and target. The final section is devoted to translating and generating languages. 3 basic approaches to performing the translation (syntax directed, rule based, model based) and implementation patterns are outlined for all 3. Finally, there is coverage of the use of string templating tools for generating output; the template can act as memory of features that occur earlier in the source but later in the target, usually obviating the need to build a model first.
If you seek to be a specialist compiler writer this is not the book for you, you will need a much more through grasp in intricacies and formalisms. If your sights are lower than that and this is you first language processing app then I would urge you to read it from cover to cover before writing a line of code and then refer back to it often. It is an area in which input is successively transformed with output from each phase constituting the input to the next so an inappropriate design decision early with come back to bite you in later phases. 
My transpiler  (https://github.com/HCumper/SBasic) is still very much a work in progress but this book has made me much more confident.
